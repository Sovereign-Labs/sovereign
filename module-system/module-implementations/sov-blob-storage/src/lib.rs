#![deny(missing_docs)]

//! Blob storage module allows to save DA blobs in the state

use sov_modules_api::Module;
use sov_modules_macros::ModuleInfo;
use sov_state::{StateMap, WorkingSet};

/// Blob storage contains only address and vector of blobs
#[derive(ModuleInfo, Clone)]
pub struct BlobStorage<C: sov_modules_api::Context> {
    /// The address of blob storage module
    /// Note: this is address is generated by the module framework and the corresponding private key is unknown.
    #[address]
    pub(crate) address: C::Address,

    /// Actual storage of blobs
    /// DA block number => vector of blobs
    /// Caller controls the order of blobs in the vector
    #[state]
    pub(crate) blobs: StateMap<u64, Vec<Vec<u8>>>,
}

/// Non standard methods for blob storage
impl<C: sov_modules_api::Context> BlobStorage<C> {
    /// Store blobs for given block number, overwrite if already exists
    pub fn store_blobs(
        &self,
        block_number: u64,
        blobs: Vec<Vec<u8>>,
        working_set: &mut WorkingSet<C::Storage>,
    ) {
        self.blobs.set(&block_number, &blobs, working_set);
    }

    /// Take all blobs for given block number, return empty vector if not exists
    /// Returned blobs are removed from the storage
    pub fn take_blobs_for_block_number(
        &self,
        block_number: u64,
        working_set: &mut WorkingSet<C::Storage>,
    ) -> Vec<Vec<u8>> {
        self.blobs
            .remove(&block_number, working_set)
            .unwrap_or_default()
    }
}

/// Empty module implementation
impl<C: sov_modules_api::Context> Module for BlobStorage<C> {
    type Context = C;
    type Config = ();
}
