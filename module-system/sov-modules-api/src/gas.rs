pub mod sov_modules_api {
    use anyhow::Result;

    use core::marker::PhantomData;

    // We add `remainder_funds` to `WorkingSet` as a simple `u64`; the gas will already be converted
    // to scalar value when charged from `WorkingSet`.

    pub struct WorkingSet<C> {
        remainder_funds: u64,
        _context: PhantomData<C>,
    }

    impl<C> WorkingSet<C> {
        pub fn new(remainder_funds: u64) -> Self {
            Self {
                remainder_funds,
                _context: PhantomData,
            }
        }

        pub fn charge_gas(&mut self, gas: u64) -> Result<()> {
            self.remainder_funds = self
                .remainder_funds
                .checked_sub(gas)
                .ok_or_else(|| anyhow::anyhow!("Not enough gas"))?;
            Ok(())
        }
    }

    pub trait GasUnit {
        fn value(&self, price: u64) -> u64;
    }

    // The `GasConfig` will have the whole implementation encapsulated by macros.

    pub trait GasConfig {
        const MANIFEST: Self;
        type GasUnit: GasUnit;

        fn get_gas_unit(key: &str) -> Option<&Self::GasUnit>;
    }

    // On the `Module`, we simply receive a `GasUnit` static type, and everything is unblocked by
    // the dynamic price calculation

    pub trait Module {
        type Context;
        type GasConfig: GasConfig;

        fn charge_gas(ws: &mut WorkingSet<Self::Context>, key: &str, price: u64) -> Result<()> {
            Self::GasConfig::get_gas_unit(key)
                .map(|unit| unit.value(price))
                .ok_or(anyhow::anyhow!("No gas unit found"))
                .and_then(|gas| ws.charge_gas(gas))
        }
    }
}

pub mod foo {
    use anyhow::Result;

    use super::sov_modules_api::{GasConfig, GasUnit, Module, WorkingSet};

    // Here we declare a custom gas unit

    pub struct FooGasUnit {
        pub a: u64,
        pub b: u64,
        pub c: u64,
    }

    impl GasUnit for FooGasUnit {
        fn value(&self, price: u64) -> u64 {
            self.a
                .saturating_add(self.b)
                .saturating_add(self.c)
                .saturating_mul(price)
        }
    }

    // The code below will be generated by a macro that will look like
    // gas_config!(FooGasConfig, FooGasUnit);

    pub struct FooGasConfig {
        pub keys: [&'static str; 2],
        pub values: [FooGasUnit; 2],
    }

    impl GasConfig for FooGasConfig {
        const MANIFEST: Self = {
            // read manifest file
            Self {
                keys: ["complex_math_operation", "some_other_operation"],
                values: [
                    FooGasUnit { a: 1, b: 2, c: 3 },
                    FooGasUnit { a: 4, b: 5, c: 6 },
                ],
            }
        };

        type GasUnit = FooGasUnit;

        fn get_gas_unit(key: &str) -> Option<&Self::GasUnit> {
            // this O(n) is an implementation detail and can be freely optimized in the future for
            // something more efficient; however, we are not expected to have a big number of
            // attributes for the gas config, so we might not need additional complexity here
            Self::MANIFEST
                .keys
                .iter()
                .position(|&k| k == key)
                .and_then(|p| Self::MANIFEST.values.get(p))
        }
    }

    // then we define a custom module

    pub struct FooModule;

    impl Module for FooModule {
        type Context = ();
        type GasConfig = FooGasConfig;
    }

    // we can charge gas using our custom unit to define the price

    impl FooModule {
        pub fn some_cool_function(ws: &mut WorkingSet<()>) -> Result<()> {
            Self::charge_gas(ws, "some_other_operation", 25)
        }
    }
}

#[test]
fn it_works() {
    use foo::FooModule;
    use sov_modules_api::WorkingSet;

    let gas = 1_000_000;
    let mut ws = WorkingSet::new(gas);

    FooModule::some_cool_function(&mut ws).unwrap();
}
