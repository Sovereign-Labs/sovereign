pub mod sov_modules_api {
    use anyhow::Result;

    use core::marker::PhantomData;

    // The `GasUnit` will be the responsible for scalar gas conversion, and will have dynamic
    // types. We are expected to provide a couple of basic types on the SDK level, and the user
    // might implement his own types

    pub trait GasUnit {
        type Price;

        fn value(&self, price: &Self::Price) -> u64;
    }

    // The `Context` will be used to define the gas unit

    pub trait Context {
        type GasUnit: GasUnit;
    }

    pub struct DefaultContext<GU>(PhantomData<GU>)
    where
        GU: GasUnit;

    impl<GU> Context for DefaultContext<GU>
    where
        GU: GasUnit,
    {
        type GasUnit = GU;
    }

    // We add `remainder_funds` to `WorkingSet` as a simple `u64`; the gas will already be converted
    // to scalar value when charged from `WorkingSet`.

    pub struct WorkingSet<C>
    where
        C: Context,
    {
        remainder_funds: u64,
        _context: PhantomData<C>,
    }

    impl<C> WorkingSet<C>
    where
        C: Context,
    {
        pub fn new(remainder_funds: u64) -> Self {
            Self {
                remainder_funds,
                _context: PhantomData,
            }
        }

        pub fn charge_gas(
            &mut self,
            gas: &C::GasUnit,
            price: &<C::GasUnit as GasUnit>::Price,
        ) -> Result<()> {
            self.remainder_funds = self
                .remainder_funds
                .checked_sub(gas.value(price))
                .ok_or_else(|| anyhow::anyhow!("Not enough gas"))?;
            Ok(())
        }
    }

    // The `GasConfig` will have the whole implementation encapsulated by macros.

    pub trait GasConfig {
        const MANIFEST: Self;
        type GasUnit: GasUnit;

        fn get_gas_unit(key: &str) -> Option<&Self::GasUnit>;
    }

    // On the `Module`, we simply receive a `GasUnit` static type, and everything is unblocked by
    // the dynamic price calculation

    pub trait Module {
        type Context: Context;
        type GasConfig: GasConfig<GasUnit = <Self::Context as Context>::GasUnit>;

        fn charge_gas(
            ws: &mut WorkingSet<Self::Context>,
            key: &str,
            price: &<<Self::GasConfig as GasConfig>::GasUnit as GasUnit>::Price,
        ) -> Result<()> {
            Self::GasConfig::get_gas_unit(key)
                .ok_or(anyhow::anyhow!("No gas unit found"))
                .and_then(|unit| ws.charge_gas(unit, price))
        }
    }
}

pub mod foo {
    use anyhow::Result;

    use super::sov_modules_api::{GasConfig, GasUnit, Module, WorkingSet};

    // Here we declare a custom gas unit

    pub struct FooGasUnit {
        pub a: u64,
        pub b: u64,
        pub c: u64,
    }

    impl GasUnit for FooGasUnit {
        type Price = String;

        fn value(&self, price: &Self::Price) -> u64 {
            let reduced = price.chars().map(|c| c as u64).sum();
            self.a
                .saturating_add(self.b)
                .saturating_add(self.c)
                .saturating_mul(reduced)
        }
    }

    // The context will be defined as concrete type for execution

    pub type FooContext = super::sov_modules_api::DefaultContext<FooGasUnit>;

    // The code below will be generated by a macro that will look like
    // gas_config!(FooGasConfig, FooGasUnit);

    pub struct FooGasConfig {
        pub keys: [&'static str; 2],
        pub values: [FooGasUnit; 2],
    }

    impl GasConfig for FooGasConfig {
        const MANIFEST: Self = {
            // read manifest file
            Self {
                keys: ["complex_math_operation", "some_other_operation"],
                values: [
                    FooGasUnit { a: 1, b: 2, c: 3 },
                    FooGasUnit { a: 4, b: 5, c: 6 },
                ],
            }
        };

        type GasUnit = FooGasUnit;

        fn get_gas_unit(key: &str) -> Option<&Self::GasUnit> {
            // this O(n) is an implementation detail and can be freely optimized in the future for
            // something more efficient; however, we are not expected to have a big number of
            // attributes for the gas config, so we might not need additional complexity here
            Self::MANIFEST
                .keys
                .iter()
                .position(|&k| k == key)
                .and_then(|p| Self::MANIFEST.values.get(p))
        }
    }

    // then we define a custom module

    pub struct FooModule;

    impl Module for FooModule {
        type Context = FooContext;
        type GasConfig = FooGasConfig;
    }

    // we can charge gas using our custom unit to define the price

    impl FooModule {
        pub fn some_cool_function(ws: &mut WorkingSet<FooContext>) -> Result<()> {
            Self::charge_gas(
                ws,
                "some_other_operation",
                &String::from("price can be anything"),
            )
        }
    }
}

#[test]
fn it_works() {
    use foo::FooModule;
    use sov_modules_api::WorkingSet;

    let gas = 1_000_000;
    let mut ws = WorkingSet::new(gas);

    FooModule::some_cool_function(&mut ws).unwrap();
}
